# Autogenerated with SMOP version 
# /Users/xupeng.tong/anaconda/bin/smop solver.m
from __future__ import division
import numpy,time
from core import *
from numpy.linalg import norm
from numpy import sign

def SolveHomotopy(A=None,b=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 2-[A,b].count(None)+len(args)

    global N,gamma_x,z_x,xk_temp,del_x_vec,pk_temp,dk,epsilon,isNonnegative
    t0=copy(tic)
    lambda_=1e-06
    maxiter=100
    isNonnegative= False
    verbose= False
    xk_1=matlabarray([])
    STOPPING_TIME=- 2
    STOPPING_GROUND_TRUTH=- 1
    STOPPING_DUALITY_GAP=1
    STOPPING_SPARSE_SUPPORT=2
    STOPPING_OBJECTIVE_VALUE=3
    STOPPING_SUBGRADIENT=4
    STOPPING_DEFAULT=copy(STOPPING_OBJECTIVE_VALUE)
    stoppingCriterion=copy(STOPPING_DEFAULT)
    if (mod(length(varargin),2) != 0):
        error(cat(char("Extra Parameters passed to the function '"),mfilename,char("' must be passed in pairs.")))
    parameterCount=length(varargin) / 2
    for parameterIndex in arange(1,parameterCount).reshape(-1):
        parameterName=varargin[parameterIndex * 2 - 1]
        parameterValue=varargin[parameterIndex * 2]
        if 'stoppingcriterion' == parameterName.lower():
            stoppingCriterion=copy(parameterValue)
        else:
            if 'initialization' == parameterName.lower():
                xk_1=copy(parameterValue)
                if not all(size(xk_1) == cat(n,1)):
                    error(char('The dimension of the initial x0 does not match.'))
            else:
                if 'groundtruth' == parameterName.lower():
                    xG=copy(parameterValue)
                else:
                    if 'lambda' == parameterName.lower():
                        lambda_=copy(parameterValue)
                    else:
                        if 'maxiteration' == parameterName.lower():
                            maxiter=copy(parameterValue)
                        else:
                            if 'isnonnegative' == parameterName.lower():
                                isNonnegative=copy(parameterValue)
                            else:
                                if 'tolerance' == parameterName.lower():
                                    tolerance=copy(parameterValue)
                                else:
                                    if 'verbose' == parameterName.lower():
                                        verbose=copy(parameterValue)
                                    else:
                                        if 'maxtime' == parameterName.lower():
                                            maxTime=copy(parameterValue)
                                        else:
                                            error(cat(char("The parameter '"),parameterName,char("' is not recognized by the function '"),mfilename,char("'.")))
    timeSteps=numpy.empty((1,maxiter))
    errorSteps=numpy.empty((1,maxiter))
    epsSteps=numpy.empty((1,maxiter))
    K,N=size(A,nargout=2)
    z_x=zeros(N,1)
    gamma_x=matlabarray([])
    Primal_constrk=- A.T * b
    if isNonnegative:
        c,i=min(Primal_constrk,d=False,nargout=0)
        c=max(- c,0)
    else:
        c,i= numpy.argmax(abs(Primal_constrk)), numpy.max(abs(Primal_constrk))
    epsilon=copy(c)
    nz_x=zeros(N,1)
    if isempty(xk_1):
        xk_1=zeros(N,1)
        gamma_xk=copy(i)
    else:
        gamma_xk=find(abs_(xk_1) > eps * 10)
        nz_x[gamma_xk]=1

    gamma_xk = int(gamma_xk)
    f=epsilon * norm(xk_1,1) + 1 / 2 * norm(b - A * xk_1) ** 2
    z_x[gamma_xk]=- sign(Primal_constrk[gamma_xk])
    z_xk=copy(z_x)
    iter_=0
    out_x=matlabarray([])
    old_delta=0
    count_delta_stop=0
    AtgxAgx=A[:,gamma_xk].T * A[:,gamma_xk]
    iAtgxAgx=inv(A[:,gamma_xk].T * A[:,gamma_xk])
    while iter_ < maxiter:

        iter_=iter_ + 1
        gamma_x=copy(gamma_xk)
        z_x=copy(z_xk)
        x_k=copy(xk_1)
        del_x=iAtgxAgx * z_x[gamma_x]
        del_x_vec=zeros(N,1)
        del_x_vec[gamma_x]=del_x
        Asupported=A[:,gamma_x][:,:,0]
        Agdelx=Asupported * del_x

        print Asupported.shape
        print del_x.shape

        dk=A.T * Agdelx
        pk_temp=copy(Primal_constrk)
        gammaL_temp=find(abs(abs(Primal_constrk) - epsilon) < min(epsilon,2 * eps))
        pk_temp[gammaL_temp]=sign(Primal_constrk[gammaL_temp]) * epsilon
        xk_temp=copy(x_k)
        xk_temp[abs_(x_k) < 2 * eps]=0
        i_delta,delta,out_x=update_primal(out_x,nargout=3)
        if old_delta < 4 * eps and delta < 4 * eps:
            count_delta_stop=count_delta_stop + 1
            if count_delta_stop >= 500:
                if verbose:
                    disp(char('stuck in some corner'))
                break
        else:
            count_delta_stop=0
        old_delta=copy(delta)
        xk_1=x_k + delta * del_x_vec
        Primal_constrk=Primal_constrk + delta * dk
        epsilon_old=copy(epsilon)
        epsilon=epsilon - delta
        if epsilon <= lambda_:
            gamma_x0=find(abs_(xk_1) > 1e-09)
            AtgxAgx0=A[:,gamma_x0].T * A[:,gamma_x0]
            x_temp=numpy.linalg.solve(AtgxAgx0,(A[:,gamma_x0].T * b))
            xk_1=zeros(N,1)
            xk_1[gamma_x0]=x_temp
            timeSteps[iter_]=toc(t0)
            errorSteps[iter_]=norm(xk_1 - xG)
            epsSteps[iter_]=epsilon
            break
        timeSteps[iter_]=toc(t0)
        errorSteps[iter_]=norm(xk_1 - xG)
        epsSteps[iter_]=epsilon
        keep_going=copy(true)
        if STOPPING_GROUND_TRUTH == stoppingCriterion:
            keep_going=norm(xk_1 - xG) > tolerance
        else:
            if STOPPING_SPARSE_SUPPORT == stoppingCriterion:
                if delta != 0:
                    nz_x_prev=copy(nz_x)
                    nz_x=(abs_(xk_1) > eps * 10)
                    num_nz_x=sum_(nz_x[:])
                    num_changes_active=(sum_(nz_x[:] != nz_x_prev[:]))
                    if num_nz_x >= 1:
                        criterionActiveSet=num_changes_active / num_nz_x
                        keep_going=(criterionActiveSet > tolerance)
            else:
                if STOPPING_DUALITY_GAP == stoppingCriterion:
                    error(char('Duality gap is not a valid stopping criterion for Homotopy.'))
                else:
                    if STOPPING_OBJECTIVE_VALUE == stoppingCriterion:
                        if delta != 0:
                            prev_f=copy(f)
                            f=lambda_ * norm(xk_1,1) + 1 / 2 * norm(b - Asupported * xk_1[gamma_x]) ** 2
                            keep_going=(abs_((prev_f - f) / prev_f) > tolerance)
                    else:
                        if STOPPING_SUBGRADIENT == stoppingCriterion:
                            keep_going=norm(delta * del_x_vec) > tolerance
                        else:
                            if STOPPING_TIME == stoppingCriterion:
                                keep_going=timeSteps[iter_] < maxTime
                            else:
                                error(char('Undefined stopping criterion'))
        if not keep_going:
            break
        if not isempty(out_x):
            len_gamma=length(gamma_x)
            outx_index=find(gamma_x == out_x[1])
            gamma_x[outx_index]=gamma_x[len_gamma]
            gamma_x[len_gamma]=out_x[1]
            gamma_x=gamma_x[1:len_gamma - 1]
            gamma_xk=copy(gamma_x)
            rowi=copy(outx_index)
            colj=copy(outx_index)
            AtgxAgx_ij=copy(AtgxAgx)
            temp_row=AtgxAgx_ij[rowi,:]
            AtgxAgx_ij[rowi,:]=AtgxAgx_ij[len_gamma,:]
            AtgxAgx_ij[len_gamma,:]=temp_row
            temp_col=AtgxAgx_ij[:,colj]
            AtgxAgx_ij[:,colj]=AtgxAgx_ij[:,len_gamma]
            AtgxAgx_ij[:,len_gamma]=temp_col
            iAtgxAgx_ij=copy(iAtgxAgx)
            temp_row=iAtgxAgx_ij[colj,:]
            iAtgxAgx_ij[colj,:]=iAtgxAgx_ij[len_gamma,:]
            iAtgxAgx_ij[len_gamma,:]=temp_row
            temp_col=iAtgxAgx_ij[:,rowi]
            iAtgxAgx_ij[:,rowi]=iAtgxAgx_ij[:,len_gamma]
            iAtgxAgx_ij[:,len_gamma]=temp_col
            AtgxAgx=AtgxAgx_ij[1:len_gamma - 1,1:len_gamma - 1]
            n=size(AtgxAgx_ij,1)
            Q11=iAtgxAgx_ij[1:n - 1,1:n - 1]
            Q12=iAtgxAgx_ij[1:n - 1,n]
            Q21=iAtgxAgx_ij[n,1:n - 1]
            Q22=iAtgxAgx_ij[n,n]
            Q12Q21_Q22=Q12 * (Q21 / Q22)
            iAtgxAgx=Q11 - Q12Q21_Q22
            xk_1[out_x[1]]=0
        else:
            gamma_xk=matlabarray(cat([gamma_x],[i_delta]))
            new_x=copy(i_delta)
            AtgxAnx=A[:,gamma_x].T * A[:,new_x]
            AtgxAgx_mod=matlabarray(cat([AtgxAgx,AtgxAnx],[AtgxAnx.T,A[:,new_x].T * A[:,i_delta]]))
            AtgxAgx=copy(AtgxAgx_mod)
            n=size(AtgxAgx,1)
            iA11=copy(iAtgxAgx)
            iA11A12=iA11 * AtgxAgx[1:n - 1,n]
            A21iA11=AtgxAgx[n,1:n - 1] * iA11
            S=AtgxAgx[n,n] - AtgxAgx[n,1:n - 1] * iA11A12
            Q11_right=iA11A12 * (A21iA11 / S)
            iAtgxAgx=zeros(n)
            iAtgxAgx[1:n - 1,1:n - 1]=iA11 + Q11_right
            iAtgxAgx[1:n - 1,n]=- iA11A12 / S
            iAtgxAgx[n,1:n - 1]=- A21iA11 / S
            iAtgxAgx[n,n]=1 / S
            xk_1[i_delta]=0
        z_xk=zeros(N,1)
        z_xk[gamma_xk]=- sign(Primal_constrk[gamma_xk])
        Primal_constrk[gamma_x]=sign(Primal_constrk[gamma_x]) * epsilon

    total_iter=copy(iter_)
    x_out=copy(xk_1)
    timeSteps=timeSteps[1:total_iter]
    errorSteps=errorSteps[1:total_iter]
    epsSteps=epsSteps[1:total_iter]
    return x_out,total_iter,timeSteps,errorSteps,epsSteps
def update_primal(out_x=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 1-[out_x].count(None)+len(args)

    global N,gamma_x,z_x,xk_temp,del_x_vec,pk_temp,dk,epsilon,isNonnegative
    gamma_lc=setdiff(arange(1,N),union(gamma_x,out_x))
    if isNonnegative:
        delta1=copy(inf)
    else:
        delta1_constr=(epsilon - pk_temp[gamma_lc]) / (1 + dk[gamma_lc])
        delta1_pos_ind=find(delta1_constr > 0)
        delta1_pos=delta1_constr[delta1_pos_ind]
        delta1,i_delta1=min(delta1_pos,nargout=2)
        if isempty(delta1):
            delta1=copy(inf)
    delta2_constr=(epsilon + pk_temp[gamma_lc]) / (1 - dk[gamma_lc])
    delta2_pos_ind=find(delta2_constr > 0)
    delta2_pos=delta2_constr[delta2_pos_ind]
    delta2,i_delta2=min(delta2_pos,nargout=2)
    if isempty(delta2):
        delta2=copy(inf)
    if delta1 > delta2:
        delta=copy(delta2)
        i_delta=gamma_lc[delta2_pos_ind[i_delta2]]
    else:
        delta=copy(delta1)
        i_delta=gamma_lc[delta1_pos_ind[i_delta1]]
    delta3_constr=(- xk_temp[gamma_x] / del_x_vec[gamma_x])
    delta3_pos_index=find(delta3_constr > 0)
    delta3,i_delta3=min(delta3_constr[delta3_pos_index],nargout=2)
    out_x_index=gamma_x[delta3_pos_index[i_delta3]]
    out_x=matlabarray([])
    if not isempty(delta3) and (delta3 > 0) and (delta3 <= delta):
        delta=copy(delta3)
        out_x=copy(out_x_index)
    xk_1=xk_temp + delta * del_x_vec
    xk_1[out_x]=0
    wrong_sign=find(sign(xk_1[gamma_x]).dot(z_x[gamma_x]) == - 1)
    if isNonnegative:
        wrong_sign=union(wrong_sign,find(xk_1[gamma_x] < 0))
    if not isempty(gamma_x[wrong_sign]):
        delta=0
        val_wrong_x,ind_wrong_x=sort(abs_(del_x_vec[gamma_x[wrong_sign]]),char('descend'),nargout=2)
        out_x=gamma_x[wrong_sign[ind_wrong_x]]
    i_delta_temp=gamma_lc[abs_(pk_temp[gamma_lc] + delta * dk[gamma_lc]) - (epsilon - delta) >= 10 * eps]
    if not isempty(i_delta_temp):
        i_delta_more=copy(i_delta_temp)
        if (length(i_delta_more) >= 1) and (not any((i_delta_temp == i_delta))):
            v_temp,i_temp=max(- pk_temp[i_delta_more] / dk[i_delta_more],nargout=2)
            i_delta=i_delta_more[i_temp]
            delta=0
            out_x=matlabarray([])
    return i_delta,delta,out_x
